
### buildpack.toml (TOML)

```toml
[[stacks]]
id = "<stack ID, globally unique, ex. io.buildpacks.stack>"
run-contrib = "/path/to/run.Dockerfile"
build-contrib = "/path/to/build.Dockerfile" 
```


A buildpack group is an ordered selection of buildpacks that may be used to build an app image by running their /bin/build executables in sequence.

Base images extend stack images using buildpacks. Similar to a stack, a base image consists of a build and run image.

A buildpack group is associated with a build image which must contain the buildpacks in the group, as well as a run image that should not contain the buildpacks.

Build and run images are provided by buildpack vendors or creators. The images may be extended with other buildpacks by the platform operator, but the operator must be willing to keep the extended images updated so that all buildpack and stack updates are available to consumers of the extended images. It is permissible, but not required, for platforms to provide automation that generates build and run images dynamically from a set a buildpacks and updates them when buildpacks, stacks, or other build/run images are updated upstream.

For each stack, a buildpack may specify in buildpack.toml:

- A run Dockerfile to contribute changes to the run base image and
- A build Dockerfile to contribute changes to the build base image

If present, these Dockerfiles must accept "stack" as a build argument, and should use “FROM $stack” to receive the argument.

Build and run images are generated by applying the designated Dockerfiles on top of each other in an order chosen by the image creator. The chosen buildpacks must be added to the build image before the Dockerfiles are applied. Build images must provide a stack ID that all buildpacks support to the buildpacks during build via the $PACK_STACK_NAME environment variable.

When a new run image is available, all associated app images containing sluglets should be rebased on the new run image.

## detect

The final resulting TOML output is stored in plan.toml.

Detection occurs in a dedicated container using the original stack build image without any buildpack, app, or operator modifications.


For example, the available buildpacks for detection may be defined via order.toml as:

```toml
[[groups]]
build-image = "packs/myimage1:build"
run-image = "packs/myimage1:run"
buildpacks = [
  { id = "sh.packs.buildpacks.nodejs", version = “latest”, optional = true },
  { id = "sh.packs.buildpacks.dotnet-core", version = “latest” },
]

[[groups]]
build-image = "packs/myimage2:build"
run-image = "packs/myimage2:run"
buildpacks = [
  { id = "sh.packs.buildpacks.nodejs", version = “latest”, optional = true },
  { id = "sh.packs.buildpacks.ruby", version = “latest” },
]

[[groups]]
build-image = "packs/myimage3:build"
run-image = "packs/myimage3:run"
buildpacks = [
  { id = "sh.packs.buildpacks.python", version = “latest” },
  { id = "sh.packs.buildpacks.ruby", version = “latest” },
]
```

### Order Definition (TOML)

```toml
[[groups]]

build-image = "<build image reference>"
run-image = "<run image reference>"
buildpacks = [{id = "<buildpack ID>", version = "<buildpack version>", optional = <:bool>}]
```