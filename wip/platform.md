## Storage

This entire specification may be implemented with:

1. One or more v2 Docker image registries AND/OR

2. One or more Docker daemons supporting v2 Docker images AND

3. An additional datastore containing the locations and credentials for registries, daemons, and VCS repositories.

## Stacks

A stack consists of a build image and a run image. Apps are built on the build image, and the resulting artifact (the sluglet) is launched on the run image. Stack images must not contain these directories:

* /launch

* /cache

* /platform

* /buildpacks

Updated versions of the run image must maintain [ABI](https://en.wikipedia.org/wiki/Application_binary_interface)[-compatibility](https://en.wikipedia.org/wiki/Application_binary_interface) with previous versions. If a sluglet launches on one version of the run image, it should launch on all future versions. Updated versions of the build image should maintain ABI-compatibility with previous versions as well, although violating this requirement will not change the behavior of existing sluglets.

A buildpack should support one or more stacks explicitly by stack ID. A buildpack should use this ID to determine what dependencies it installs into the sluglet and cache.

### Base Image Generation (more options [here](https://docs.google.com/document/d/13OUWn8-ZNJwFjklJJ462_zvtHdTGUaYtUuhjlXO0QJQ/edit#))

Base images extend stack images using buildpacks. Similar to a stack, a base image consists of a build and run image.

A buildpack group is an ordered selection of buildpacks that may be used to build an app image by running their /bin/build executables in sequence. A buildpack group is associated with a build image which must contain the buildpacks in the group, as well as a run image that should not contain the buildpacks.

Build and run images are provided by buildpack vendors or creators. The images may be extended with other buildpacks by the platform operator, but the operator must be willing to keep the extended images updated so that all buildpack and stack updates are available to consumers of the extended images. It is permissible, but not required, for platforms to provide automation that generates build and run images dynamically from a set a buildpacks and updates them when buildpacks, stacks, or other build/run images are updated upstream.

For each stack, a buildpack may specify in buildpack.toml:

- A run Dockerfile to contribute changes to the run base image and
- A build Dockerfile to contribute changes to the build base image


If present, these Dockerfiles must accept "stack" as a build argument, and should use “FROM $stack” to receive the argument.

Build and run images are generated by applying the designated Dockerfiles on top of each other in an order chosen by the image creator. The chosen buildpacks must be added to the build image before the Dockerfiles are applied. Build images must provide a stack ID that all buildpacks support to the buildpacks during build via the $PACK_STACK_NAME environment variable.

When a new run image is available, all associated app images containing sluglets should be rebased on the new run image.

## detect

The final resulting TOML output is stored in plan.toml.

Detection occurs in a dedicated container using the original stack build image without any buildpack, app, or operator modifications.


For example, the available buildpacks for detection may be defined via order.toml as:

```toml
[[groups]]
build-image = "packs/myimage1:build"
run-image = "packs/myimage1:run"
buildpacks = [
  { id = "sh.packs.buildpacks.nodejs", version = “latest”, optional = true },
  { id = "sh.packs.buildpacks.dotnet-core", version = “latest” },
]

[[groups]]
build-image = "packs/myimage2:build"
run-image = "packs/myimage2:run"
buildpacks = [
  { id = "sh.packs.buildpacks.nodejs", version = “latest”, optional = true },
  { id = "sh.packs.buildpacks.ruby", version = “latest” },
]

[[groups]]
build-image = "packs/myimage3:build"
run-image = "packs/myimage3:run"
buildpacks = [
  { id = "sh.packs.buildpacks.python", version = “latest” },
  { id = "sh.packs.buildpacks.ruby", version = “latest” },
]
```


## build

1. Suitable build and run base images are located.

User-provided environment variables intended for build and launch SHOULD NOT come from the same list.
The user SHOULD be encouraged to define them separately.
Platform operators MAY determine the initial build-time and runtime environment.

The lifecycle MUST NOT assume that all platforms provide an identical environment.

## formats

### Order Definition (TOML)

```toml
[[groups]]

build-image = "<build image reference>"
run-image = "<run image reference>"
buildpacks = [{id = "<buildpack ID>", version = "<buildpack version>", optional = <:bool>}]
```

### Build Metadata (TOML)
```toml
buildpacks = ["<buildpack ID>"]

[[processes]]
type = "<process type>"
command = "<command>"
```

### Image Layers: Sluglet (SLUG + dropLET, final name TBD)

Where <id> is a globally-unique buildpack identifier.

Where <layer> is an identifier chosen by the buildpack representing the contents of the layer

**Image FS Layers (for each layer for each buildpack)**

/launch/<id>/<layer>/		contains: <launch>/<layer>/

**Image FS Layer**

/launch/app/			contains: <app>/

**Image FS Layer**

/launch/config/			contains: metadata.toml (for launch)

**Image Config Layer**

LABEL				buildpack names and versions

LABEL				layer metadata for each layer

### Image Layers: Cache

Where <id> is a globally-unique buildpack identifier.

Where <layer> is an identifier chosen by the buildpack representing the contents of the layer

**Image FS Layers (for each layer for each buildpack)**

/cache/<id>/<layer>/		contains: <cache>/<layer>/

**Mount or Ephemeral Copy**

/launch/app/			contains: <app>/

Note 1: test/development cache is stored separately from the sluglet cache.

Note 2: cache may or may not be stored in a registry

## Runtime Layer Rebasing

Runtime layer rebasing allows for O(CF) or O(Heroku) performance when updating OS-level dependencies, with regard to data transfer. When a new run base image is available, the first sluglet layer is rebased on the new run base image with remote image metadata manipulation. Similarly, individual sluglet layers MAY be replaced by successive remote rebase and/or append operations.

## Security Model

Implementations of this specification SHOULD run detection steps as well as the inner execution steps (2-5, which do not require reading or writing to an image repository) in a separate container (or at least a separate process space) that does not include credentials for access to any of the resources defined in this document. Neither buildpack code nor app code SHOULD be trusted with these types of credentials.

## Layer Caching

The purpose of layer caching is to
1. Minimize the execution time of the build phase.
2. Minimize persistent disk usage. 

This is achieved by
1. Reducing the number of build operations.
2. Reducing data transfer. 
3. Enabling de-duplication of stored image layers.
